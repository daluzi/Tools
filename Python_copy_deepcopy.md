# Python的赋值、浅拷贝和深拷贝

```python
什么是原子类型呢？我们可以理解为最简单的类型，它包括：数字、字符串。
什么是变量类型呢？标量就是Python为我们提供的标准变量类型，它包括：list， tuple， dict三种。
list， tuple， dict中不仅可以存储原子类型的数据，又可以存储各种标量；而原子类型却只能去给标量类型当小弟。观察这两种类型的变量，我们可以明显的发现标量相对于原子要复杂的多。赋值、浅拷贝与深拷贝之间的区别就存在于逼格很高的老大哥（标量）身上。
原子类型的变量的值当且仅当进行赋值操作时才会改变，而且在进行操作时总是不改变内存上的数据，而是改变变量的指向。而在标量类型中除了不可改变的tuple以外，list与dict类型的变量除了赋值操作还有可以使其改变的操作（如list.append()操作），这些操作都是在其内存上改变数据。
```
**因此，只有在标量类型的变量身上，才会存在赋值和拷贝的问题**

对于简单的Python对象，例如数值、字符串，元组（tuple不允许被更改)采用的是复制的方式(深拷贝?)，也就是说当将另一个变量B赋值给变量A时，虽然A和B的内存空间仍然相同，但当A的值发生变化时，会重新给A分配空间，A和B的地址变得不再相同.

而对于像字典(dict)，列表(List)等，改变一个就会引起另一个的改变，也称之为浅拷贝

Python中所有的变量都是引用变量

```python
>>> a = 1000    # 1000 为对象本人 
>>> b =a        # a为指向1000的引用 
>>> a is b
True            # a，b指向同一对象
>>> a = 1000
>>> b = 1000　　# 两个1000为不同的对象
>>> a is b
False           # a ，b指向不同的对象 
>>> a = (1,2,3)
>>> b = (1,2,3) # 两个(1,2,3)为不同的对象
>>> a is b
False           #   a ，b指向不同的对象 
>>> b = a      
>>> a is b
True            # a，b指向同一对象

#list与dict与上列情况相同，略  



#然而有趣的是有下列情况：

>>> a = 1
>>> b = 1
>>> a is b
True
>>> a = "asdffasdfffgbf"
>>> b = "asdffasdfffgbf"
>>> a is b
True
"""
我们发现尽管是分别赋值，a与b确依然指向同一对象。这是为什么呢？

  原来在Python中为了节省存储空间，将0~256之间的重复数字都使用同一存储位置。{而字符串由于出现的没有太多随机性，为了节省内存所以在使用时提前在内存中检查一遍，况且并不会耗费太长时间。}（大括号内为猜想）
"""
```



**拷贝与赋值的本质区别就是：拷贝是复制（重新开辟一块内存并存储对应数据）一个对象的操作。拷贝只存在标量类型之间。**

```python
import copy     #引入copy模板，进行深拷贝
>>> a = [1,2,3,4]
>>> b = ["abc","bcd","cde",a]  #b中包含对a（对[1,2,3,4]的引用)
>>> c = b.copy() # c为b的浅拷贝
>>> d = copy.deepcopy(b) # d为b的深拷贝 
>>> b
['abc', 'bcd', 'cde', [1, 2, 3, 4]]
>>> c
['abc', 'bcd', 'cde', [1, 2, 3, 4]]
>>> d
['abc', 'bcd', 'cde', [1, 2, 3, 4]]

#^^^输出bcd

>>> b[3].append(5) # [1,2,3,4].append(5)
>>> b
['abc', 'bcd', 'cde', [1, 2, 3, 4, 5]]
>>> c
['abc', 'bcd', 'cde', [1, 2, 3, 4, 5]]  #c中的数据跟着改变，说明c[3]是对  原[1,2,3,4]  的一个引用
>>> d
['abc', 'bcd', 'cde', [1, 2, 3, 4]]  #d中的数据不被影响，说明d[3]是一个不同的[1,2,3,4]
>>> b.pop()
[1, 2, 3, 4, 5]    # b中删除a指向的对象
>>> c
['abc', 'bcd', 'cde', [1, 2, 3, 4, 5]]  # c不改变，说明c是一个复制
>>> b.append(6)
>>> b
['abc', 'bcd', 'cde', 6]
>>> c
['abc', 'bcd', 'cde', [1, 2, 3, 4, 5]]
>>> a.append("c[3]是对原来a指向的对象的一个引用")
>>> c
['abc', 'bcd', 'cde', [1, 2, 3, 4, 5, 'c[3]是对原来a指向的对象的一个引用']]
```

